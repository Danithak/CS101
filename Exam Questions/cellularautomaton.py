#!/usr/bin/python
# Question 3-star: Elementary Cellular Automaton

# Please see the video for additional explanation.

# A one-dimensional cellular automata takes in a string, which in our 
# case, consists of the characters '.' and 'x', and changes it according 
# to some predetermined rules. The rules consider three characters, which 
# are a character at position k and its two neighbours, and determine 
# what the character at the corresponding position k will be in the new 
# string.

# For example, if the character at position k in the string  is '.' and 
# its neighbours are '.' and 'x', then the pattern is '..x'. We look up 
# '..x' in the table below. In the table, '..x' corresponds to 'x' which 
# means that in the new string, 'x' will be at position k.

# Rules:
#          pattern in         position k in        contribution to
# Value    current string     new string           pattern number
#                                                  is 0 if replaced by '.'
#                                                  and value if replaced
#                                                  by 'x'
#   1       '...'               '.'                        1 * 0
#   2       '..x'               'x'                        2 * 1
#   4       '.x.'               'x'                        4 * 1
#   8       '.xx'               'x'                        8 * 1
#  16       'x..'               '.'                       16 * 0
#  32       'x.x'               '.'                       32 * 0
#  64       'xx.'               '.'                       64 * 0
# 128       'xxx'               'x'                      128 * 1
#                                                      ----------
#                                                           142

# To calculate the patterns which will have the central character x, work 
# out the values required to sum to the pattern number. For example,
# 32 = 32 so only pattern 32 which is x.x changes the central position to
# an x. All the others have a . in the next line.

# 23 = 16 + 4 + 2 + 1 which means that 'x..', '.x.', '..x' and '...' all 
# lead to an 'x' in the next line and the rest have a '.'

# For pattern 142, and starting string
# ...........x...........
# the new strings created will be
# ..........xx...........  (generations = 1)
# .........xx............  (generations = 2)
# ........xx.............  (generations = 3)
# .......xx..............  (generations = 4)
# ......xx...............  (generations = 5)
# .....xx................  (generations = 6)
# ....xx.................  (generations = 7)
# ...xx..................  (generations = 8)
# ..xx...................  (generations = 9)
# .xx....................  (generations = 10)

# Note that the first position of the string is next to the last position 
# in the string.

# Define a procedure, cellular_automaton, that takes three inputs: 
#     a non-empty string, 
#     a pattern number which is an integer between 0 and 255 that
# represents a set of rules, and 
#     a positive integer, n, which is the number of generations. 
# The procedure should return a string which is the result of
# applying the rules generated by the pattern to the string n times.

# My procedure uses a helper function that first creates a pattern out of a number of 1-255
# by matching up its binary number with a pattern. The helper function uses modulo to figure
# out if a bit should be on or off and loops through the numbers list to figure out which are on
# and off. 
# Example: c = 155          Pattern:            Return value:
# 155 % 128 == 27 on        xxx                 x
# 27 % 64 == 27 off         xx.                 .
# 27 % 32 == 27 off         x.x                 .
# 27 % 16 == 11 on          x..                 x
# 11 % 8 == 3 on            .xx                 x
# 3 % 4 == 3 off            .x.                 . 
# 3 % 2 == 1 on             ..x                 x
# 1 % 1 == 0 on             ...                 x

# Example string: .x...xxxx
# To get the next generation, you loop through each character and evaluate it to an 
# x or . based off of the above information. The first character uses the last, first, and second
# character to evaluate and the last character uses the first, next to last, and last character to 
# evaluate:

# .x...xxxx -> first character: . -> combines last and second (left and right) to form x.x 
# -> x.x forms . per pattern and return value above. Automating the string to the next
# generation would evaluate as follows: .x...xxxx
#                                       ..xxxxxx.



def create_pattern(c):
    listdict = ['...', '..x', '.x.', '.xx', 'x..', 'x.x', 'xx.', 'xxx']
    numbers = [128, 64, 32, 16, 8, 4, 2, 1]
    newdict = {'...' : 1, '..x' : 2, '.x.' : 4, '.xx' : 8, 'x..' : 16, 'x.x' : 32, 'xx.' : 064, 'xxx' : 128}
    thislist = []
    for i in numbers:
        b = c
        c = b % i   # Takes c and returns modulo value of i to see if bit is on or off. 
        if c != b:  # Compares c to b, as if b does not change, the bit is off (no change
            thislist.append('x') # after modulo procedure). Appends an x if b changes (on,
        else:                    # modulo changed the number) or an . if b doesn't change (off).
            thislist.append('.')
    thislist.reverse()      # Reverses lists as modulo operated backwards to check correctly. 
    e = 0
    for i in listdict:
        newdict[i] = thislist[e] # Matches up each number in numbers with the appropriate value in newdict. 
        e += 1      # e used as value to loop through values in numbers list. 
    return newdict  # returns newly formed pattern. 

def cellular_automaton(string, pattern, x):
    pattern = create_pattern(pattern)
    n = 1
    firstgen = string   # Creates a copy of the current generation fo the string.
    nextgen = ''        # New variable to track formation of next generation.
    while n <= x:       # Loops through each variable of x.
        e = 0              # Creates another variable to allow for mutation.
        for i in firstgen:
            if e == (len(firstgen) - 1):    # Checks if character is on the end, only exception necessary. 
                genrange = firstgen[e - 1] + firstgen[e] + firstgen[0]
            else:
                genrange = firstgen[e - 1] + firstgen[e] + firstgen[e + 1] 
            nextgen += pattern[genrange]    # Concatenates characters to create next generation string 
            e += 1              # Increments through each vale of the string. 
        n += 1                  # Loops until n <= x.
        firstgen = nextgen      # Updates firstgen to allow for next level of mutation.  
        nextgen = ''            # Resets next generation. 
    return firstgen             # Returns firstgen when loop finishes. 



print cellular_automaton('.x.x.x.x.', 17, 2)
#>>> xxxxxxx..
print cellular_automaton('.x.x.x.x.', 249, 3)
#>>> .x..x.x.x
print cellular_automaton('...x....', 125, 1)
#>>> xx.xxxxx
print cellular_automaton('...x....', 125, 2)
#>>> .xxx....
print cellular_automaton('...x....', 125, 3)
#>>> .x.xxxxx
print cellular_automaton('...x....', 125, 4)
#>>> xxxx...x
print cellular_automaton('...x....', 125, 5)
#>>> ...xxx.x
print cellular_automaton('...x....', 125, 6)
#>>> xx.x.xxx
print cellular_automaton('...x....', 125, 7)
#>>> .xxxxx..
print cellular_automaton('...x....', 125, 8)
#>>> .x...xxx
print cellular_automaton('...x....', 125, 9)
#>>> xxxx.x.x
print cellular_automaton('...x....', 125, 10)
#>>> ...xxxxx


# Professor's solution:

def cellular_automaton_prof(string, pattern_number, generations):
    patterns = {}
    pattern_list = ['...', '..x', '.x.', '.xx', 'x..', 'x.x', 'xx.', 'xxx']
    n = len(string)
    for i in range(7, -1, -1):          # Loops through numbers in reverse using range function. 
        if pattern_number/(2**i) == 1:      # Divides by number to its appropriate power of 2 using 
            patterns[pattern_list[i]] = 'x' # floor division (it will return one if the pattern number
            pattern_number -= 2**i          # is larger). If the number is larger or the same, it 
        else:                               # evaluates to 'x', otherwise it evaluates to '.'
            patterns[pattern_list[i]] = '.' # in the pattern. 
    for j in range(0, generations):
        new_string = ''                     # The next lines then evaluate the next generation
        for i in range(0, n):               # using the created pattern. 
            pattern = string[i-1] + string[i] + string[(i+1)%n]
            new_string += patterns[pattern]
        string = new_string
    return new_string

print cellular_automaton_prof('.x.x.x.x.', 17, 2)
#>>> xxxxxxx..
print cellular_automaton_prof('.x.x.x.x.', 249, 3)
#>>> .x..x.x.x
print cellular_automaton_prof('...x....', 125, 1)
#>>> xx.xxxxx
print cellular_automaton_prof('...x....', 125, 2)
#>>> .xxx....
print cellular_automaton_prof('...x....', 125, 3)
#>>> .x.xxxxx
print cellular_automaton_prof('...x....', 125, 4)
#>>> xxxx...x
print cellular_automaton_prof('...x....', 125, 5)
#>>> ...xxx.x
print cellular_automaton_prof('...x....', 125, 6)
#>>> xx.x.xxx
print cellular_automaton_prof('...x....', 125, 7)
#>>> .xxxxx..
print cellular_automaton_prof('...x....', 125, 8)
#>>> .x...xxx
print cellular_automaton_prof('...x....', 125, 9)
#>>> xxxx.x.x
print cellular_automaton_prof('...x....', 125, 10)
#>>> ...xxxxx